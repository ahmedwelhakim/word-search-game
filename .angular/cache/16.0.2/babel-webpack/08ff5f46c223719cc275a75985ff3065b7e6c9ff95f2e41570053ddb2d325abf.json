{"ast":null,"code":"import { Direction } from '../models/directions.model';\nimport { Letter } from '../models/letter.model';\nimport { Point } from '../models/point.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas.service\";\nclass BoardService {\n  constructor(canvasService) {\n    this.canvasService = canvasService;\n    this.letterVals = [];\n    this.letters = [];\n    this.lang = 'ar';\n    this._offsetX = 0;\n    this._offsetY = 0;\n    this._boxSize = 0;\n    this.usedLetterIndexesMap = new Map();\n    this.ctx = this.canvasService.ctx;\n  }\n  initLetterVals(rows, cols) {\n    // Fill the board with random letters\n    this.letterVals = [];\n    for (let i = 0; i < rows; i++) {\n      this.letterVals.push([]);\n      for (let j = 0; j < cols; j++) {\n        this.letterVals[i].push(Letter.getRandomLetter(this.lang));\n      }\n    }\n  }\n  initLetter(rows, cols) {\n    this.letters = [];\n    for (let i = 0; i < rows; i++) {\n      this.letters.push([]);\n      for (let j = 0; j < cols; j++) {\n        this.letters[i].push(Letter.from(this.letterVals[i][j], Point.from(0, 0), 0));\n      }\n    }\n  }\n  fillBoard(rows, cols, words) {\n    this.initLetterVals(rows, cols);\n    this.initLetter(rows, cols);\n    for (let word of words) {\n      const randDir = Direction.randomDirection;\n      const [startI, startJ] = this.getValidRandomBeginningIndex(word, randDir);\n      this.fillWord(word, startI, startJ, randDir);\n    }\n    this.updateLettersAndSizes();\n  }\n  fillWord(word, i, j, dir) {\n    const len = word.length;\n    const wordLettersReversed = word.split('').reverse();\n    this.doInDirection(dir, i, j, len, (i, j) => {\n      const letter = wordLettersReversed.pop();\n      this.letterVals[i][j] = letter;\n      this.letters[i][j].updateColors('khaki');\n      this.usedLetterIndexesMap.set(`${i},${j}`, letter);\n    });\n  }\n  getValidRandomBeginningIndex(word, direction) {\n    let randI = Math.floor(Math.random() * this.rows);\n    let randJ = Math.floor(Math.random() * this.cols);\n    while (!this.isValidIndex(randI, randJ, word, direction)) {\n      randI = Math.floor(Math.random() * this.rows);\n      randJ = Math.floor(Math.random() * this.cols);\n    }\n    return [randI, randJ];\n  }\n  isValidIndex(i, j, word, direction) {\n    const len = word.length;\n    const max_cols = this.cols;\n    const max_rows = this.rows;\n    let result = false;\n    switch (direction) {\n      case Direction.N:\n        result = i >= len - 1;\n        break;\n      case Direction.S:\n        result = i <= max_rows - len;\n        break;\n      case Direction.E:\n        result = j <= max_cols - len;\n        break;\n      case Direction.W:\n        result = j >= len - 1;\n        break;\n      case Direction.NE:\n        result = i >= len - 1 && j <= max_cols - len;\n        break;\n      case Direction.SE:\n        result = i <= max_rows - len && j <= max_cols - len;\n        break;\n      case Direction.NW:\n        result = i >= len - 1 && j >= len - 1;\n        break;\n      case Direction.SW:\n        result = i <= max_rows - len && j >= len - 1;\n        break;\n    }\n    if (!result) return false;\n    // Handle the case if letter will override other valid word letter\n    this.doInDirection(direction, i, j, len, (i2, j2, counter) => {\n      if (this.usedLetterIndexesMap.has(`${i2},${j2}`) && this.usedLetterIndexesMap.get(`${i2},${j2}`) !== word[counter]) {\n        result = false;\n      }\n    });\n    return result;\n  }\n  draw() {\n    this.ctx.beginPath();\n    for (let row of this.letters) {\n      for (let letter of row) {\n        letter.draw(this.ctx);\n      }\n    }\n  }\n  updateLettersAndSizes() {\n    const width = this.canvasService.canvas.width / this.cols;\n    const height = this.canvasService.canvas.height / this.rows;\n    this._boxSize = Math.min(width, height);\n    this._offsetX = (width - this.boxSize) * this.cols / 2;\n    this._offsetY = (height - this.boxSize) * this.rows / 2;\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.cols; j++) {\n        this.letters[i][j].update(this.letterVals[i][j], Point.from(j * this.boxSize + this.offsetX, i * this.boxSize + this.offsetY), this.boxSize);\n      }\n    }\n  }\n  translatePointToIndices(point) {\n    // Remove all offsets\n    let offsetX = -this.boxSize / 2;\n    offsetX -= this._offsetX;\n    let offsetY = -this.boxSize / 2;\n    offsetY -= this._offsetY;\n    const j = Math.round((point.x + offsetX) / this.boxSize);\n    const i = Math.round((point.y + offsetY) / this.boxSize);\n    return [i, j];\n  }\n  isInBoard(...points) {\n    for (let point of points) {\n      if (point.x < this.topLeftPoint.x || point.x > this.bottomRightPoint.x) return false;\n      if (point.y < this.topLeftPoint.y || point.y > this.bottomRightPoint.y) return false;\n    }\n    return true;\n  }\n  getWord(startPoint, endPoint) {\n    if (!this.isInBoard(startPoint) || !this.isInBoard(endPoint)) return '';\n    const [i1, j1] = this.translatePointToIndices(startPoint);\n    const [i2, j2] = this.translatePointToIndices(endPoint);\n    const direction = Direction.getDirection(startPoint, endPoint);\n    let res = [];\n    const distanceLength = Math.max(Math.abs(i2 - i1), Math.abs(j2 - j1)) + 1;\n    if (i1 === i2 && j1 === j2) return this.letterVals?.[i1]?.[j1] || '';\n    res = this.doInDirection(direction, i1, j1, distanceLength, (i, j) => {\n      return this.letterVals?.[i]?.[j] || '';\n    });\n    return res.join('');\n  }\n  doInDirection(direction, startI, startJ, len, fn) {\n    const res = [];\n    let endI;\n    let endJ;\n    let diff;\n    let counter = 0;\n    switch (direction) {\n      // from Left To Right\n      case Direction.E:\n        endJ = startJ + len - 1;\n        for (let j = startJ; j <= endJ; j++) {\n          res.push(fn(startI, j, counter++));\n        }\n        break;\n      // from Right To Left\n      case Direction.W:\n        endJ = startJ - len + 1;\n        for (let j = startJ; j >= endJ; j--) {\n          res.push(fn(startI, j, counter++));\n        }\n        break;\n      // from Top to Bottom\n      case Direction.S:\n        endI = startI + len - 1;\n        for (let i = startI; i <= endI; i++) {\n          res.push(fn(i, startJ, counter++));\n        }\n        break;\n      // from Bottom to Top\n      case Direction.N:\n        endI = startI - len + 1;\n        for (let i = startI; i >= endI; i--) {\n          res.push(fn(i, startJ, counter++));\n        }\n        break;\n      // i is decreasing\n      // j is increasing\n      case Direction.NE:\n        endJ = startJ + len - 1;\n        diff = Math.abs(endJ - startJ);\n        for (let i = 0; i <= diff; i++) {\n          res.push(fn(startI - i, startJ + i, counter++));\n        }\n        break;\n      // i is increasing\n      // j is decreasing\n      case Direction.SW:\n        endJ = startJ - len + 1;\n        diff = Math.abs(endJ - startJ);\n        for (let i = 0; i <= diff; i++) {\n          res.push(fn(startI + i, startJ - i, counter++));\n        }\n        break;\n      // i is decreasing\n      // j is decreasing\n      case Direction.NW:\n        endJ = startJ - len + 1;\n        diff = Math.abs(endJ - startJ);\n        for (let i = 0; i <= diff; i++) {\n          res.push(fn(startI - i, startJ - i, counter++));\n        }\n        break;\n      // i is increasing\n      // j is increasing\n      case Direction.SE:\n        endJ = startJ + len - 1;\n        diff = Math.abs(endJ - startJ);\n        for (let i = 0; i <= diff; i++) {\n          res.push(fn(startI + i, startJ + i, counter++));\n        }\n        break;\n    }\n    return res;\n  }\n  get offsetX() {\n    return this._offsetX;\n  }\n  get offsetY() {\n    return this._offsetY;\n  }\n  get boxSize() {\n    return this._boxSize;\n  }\n  get rows() {\n    return this.letterVals.length;\n  }\n  get cols() {\n    return this.letterVals?.[0]?.length || 0;\n  }\n  get topLeftPoint() {\n    return Point.from(this.offsetX, this.offsetY);\n  }\n  get topRightPoint() {\n    return Point.from(this.offsetX + this.boxSize * this.cols, this.offsetY);\n  }\n  get bottomLeftPoint() {\n    return Point.from(this.offsetX, this.offsetY + this.boxSize * this.rows);\n  }\n  get bottomRightPoint() {\n    return Point.from(this.offsetX + this.boxSize * this.cols, this.offsetY + this.boxSize * this.rows);\n  }\n}\nBoardService.ɵfac = function BoardService_Factory(t) {\n  return new (t || BoardService)(i0.ɵɵinject(i1.CanvasService));\n};\nBoardService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BoardService,\n  factory: BoardService.ɵfac\n});\nexport { BoardService };","map":{"version":3,"names":["Direction","Letter","Point","BoardService","constructor","canvasService","letterVals","letters","lang","_offsetX","_offsetY","_boxSize","usedLetterIndexesMap","Map","ctx","initLetterVals","rows","cols","i","push","j","getRandomLetter","initLetter","from","fillBoard","words","word","randDir","randomDirection","startI","startJ","getValidRandomBeginningIndex","fillWord","updateLettersAndSizes","dir","len","length","wordLettersReversed","split","reverse","doInDirection","letter","pop","updateColors","set","direction","randI","Math","floor","random","randJ","isValidIndex","max_cols","max_rows","result","N","S","E","W","NE","SE","NW","SW","i2","j2","counter","has","get","draw","beginPath","row","width","canvas","height","min","boxSize","update","offsetX","offsetY","translatePointToIndices","point","round","x","y","isInBoard","points","topLeftPoint","bottomRightPoint","getWord","startPoint","endPoint","i1","j1","getDirection","res","distanceLength","max","abs","join","fn","endI","endJ","diff","topRightPoint","bottomLeftPoint","i0","ɵɵinject","CanvasService","factory","ɵfac"],"sources":["/home/ahmed/Documents/projects/word-matcher/src/app/game/services/board.service.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\nimport {Angle} from '../models/angle.model';\nimport {Direction, DirectionVal} from '../models/directions.model';\nimport {Letter} from '../models/letter.model';\nimport {Point} from '../models/point.model';\nimport {CanvasService} from './canvas.service';\n\n@Injectable()\nexport class BoardService {\n  ctx: CanvasRenderingContext2D;\n  letterVals: string[][] = [];\n  letters: Letter[][] = [];\n  lang = 'ar';\n  private _offsetX = 0;\n  private _offsetY = 0;\n  private _boxSize = 0;\n  private usedLetterIndexesMap = new Map<string, string>();\n\n  constructor(private canvasService: CanvasService) {\n    this.ctx = this.canvasService.ctx;\n  }\n\n  private initLetterVals(rows: number, cols: number) {\n    // Fill the board with random letters\n    this.letterVals = [];\n\n    for (let i = 0; i < rows; i++) {\n      this.letterVals.push([]);\n      for (let j = 0; j < cols; j++) {\n        this.letterVals[i].push(Letter.getRandomLetter(this.lang));\n      }\n    }\n  }\n\n  private initLetter(rows: number, cols: number) {\n    this.letters = [];\n\n    for (let i = 0; i < rows; i++) {\n      this.letters.push([]);\n      for (let j = 0; j < cols; j++) {\n        this.letters[i].push(\n          Letter.from(this.letterVals[i][j], Point.from(0, 0), 0)\n        );\n      }\n    }\n  }\n\n  fillBoard(rows: number, cols: number, words: string[]) {\n    this.initLetterVals(rows, cols);\n    this.initLetter(rows, cols);\n\n    for (let word of words) {\n      const randDir = Direction.randomDirection;\n      const [startI, startJ] = this.getValidRandomBeginningIndex(word, randDir);\n      this.fillWord(word, startI, startJ, randDir);\n    }\n    this.updateLettersAndSizes();\n  }\n\n  private fillWord(word: string, i: number, j: number, dir: DirectionVal) {\n    const len = word.length;\n    const wordLettersReversed = word.split('').reverse();\n    this.doInDirection(dir, i, j, len, (i, j) => {\n      const letter = wordLettersReversed.pop()!;\n      this.letterVals[i][j] = letter;\n      this.letters[i][j].updateColors('khaki');\n      this.usedLetterIndexesMap.set(`${i},${j}`, letter);\n    });\n  }\n\n  private getValidRandomBeginningIndex(\n    word: string,\n    direction: DirectionVal\n  ): [number, number] {\n    let randI = Math.floor(Math.random() * this.rows);\n    let randJ = Math.floor(Math.random() * this.cols);\n    while (!this.isValidIndex(randI, randJ, word, direction)) {\n      randI = Math.floor(Math.random() * this.rows);\n      randJ = Math.floor(Math.random() * this.cols);\n    }\n    return [randI, randJ];\n  }\n\n  private isValidIndex(i: number, j: number, word: string, direction: DirectionVal) {\n    const len = word.length;\n    const max_cols = this.cols;\n    const max_rows = this.rows;\n    let result = false;\n    switch (direction) {\n      case Direction.N:\n        result = i >= len - 1;\n        break;\n      case Direction.S:\n        result = i <= max_rows - len;\n        break;\n      case Direction.E:\n        result = j <= max_cols - len;\n        break;\n      case Direction.W:\n        result = j >= len - 1;\n        break;\n      case Direction.NE:\n        result = i >= len - 1 && j <= max_cols - len;\n        break;\n      case Direction.SE:\n        result = i <= max_rows - len && j <= max_cols - len;\n        break;\n      case Direction.NW:\n        result = i >= len - 1 && j >= len - 1;\n        break;\n      case Direction.SW:\n        result = i <= max_rows - len && j >= len - 1;\n        break;\n    }\n    if (!result) return false;\n\n    // Handle the case if letter will override other valid word letter\n    this.doInDirection(direction, i, j, len, (i2, j2, counter) => {\n      if (\n        this.usedLetterIndexesMap.has(`${i2},${j2}`) &&\n        this.usedLetterIndexesMap.get(`${i2},${j2}`) !== word[counter]\n      ) {\n        result = false;\n      }\n    });\n    return result;\n  }\n\n  draw() {\n    this.ctx.beginPath();\n    for (let row of this.letters) {\n      for (let letter of row) {\n        letter.draw(this.ctx);\n      }\n    }\n  }\n\n  updateLettersAndSizes() {\n    const width = this.canvasService.canvas.width / this.cols;\n    const height = this.canvasService.canvas.height / this.rows;\n    this._boxSize = Math.min(width, height);\n\n    this._offsetX = ((width - this.boxSize) * this.cols) / 2;\n    this._offsetY = ((height - this.boxSize) * this.rows) / 2;\n\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.cols; j++) {\n        this.letters[i][j].update(\n          this.letterVals[i][j],\n          Point.from(\n            j * this.boxSize + this.offsetX,\n            i * this.boxSize + this.offsetY\n          ),\n          this.boxSize\n        );\n      }\n    }\n  }\n\n  private translatePointToIndices(point: Point): [number, number] {\n    // Remove all offsets\n    let offsetX = -this.boxSize / 2;\n    offsetX -= this._offsetX;\n    let offsetY = -this.boxSize / 2;\n    offsetY -= this._offsetY;\n\n    const j = Math.round((point.x + offsetX) / this.boxSize);\n\n    const i = Math.round((point.y + offsetY) / this.boxSize);\n\n    return [i, j];\n  }\n\n  isInBoard(...points: Point[]): boolean {\n    for (let point of points) {\n      if (point.x < this.topLeftPoint.x || point.x > this.bottomRightPoint.x)\n        return false;\n      if (point.y < this.topLeftPoint.y || point.y > this.bottomRightPoint.y)\n        return false;\n    }\n    return true;\n  }\n\n  getWord(startPoint: Point, endPoint: Point): string {\n    if (!this.isInBoard(startPoint) || !this.isInBoard(endPoint)) return '';\n    const [i1, j1] = this.translatePointToIndices(startPoint);\n    const [i2, j2] = this.translatePointToIndices(endPoint);\n\n    const direction = Direction.getDirection(startPoint, endPoint);\n    let res: string[] = [];\n    const distanceLength = Math.max(Math.abs(i2 - i1), Math.abs(j2 - j1)) + 1;\n    if (i1 === i2 && j1 === j2) return this.letterVals?.[i1]?.[j1] || '';\n    res = this.doInDirection(direction, i1, j1, distanceLength, (i, j) => {\n      return this.letterVals?.[i]?.[j] || '';\n    });\n\n    return res.join('');\n  }\n\n  doInDirection<T extends any>(\n    direction: DirectionVal,\n    startI: number,\n    startJ: number,\n    len: number,\n    fn: (i: number, j: number, counter: number) => T\n  ) {\n    const res: T[] = [];\n    let endI: number;\n    let endJ: number;\n    let diff;\n    let counter = 0;\n    switch (direction) {\n      // from Left To Right\n      case Direction.E:\n        endJ = startJ + len - 1;\n        for (let j = startJ; j <= endJ; j++) {\n          res.push(fn(startI, j, counter++));\n        }\n        break;\n      // from Right To Left\n      case Direction.W:\n        endJ = startJ - len + 1;\n        for (let j = startJ; j >= endJ; j--) {\n          res.push(fn(startI, j, counter++));\n        }\n        break;\n\n      // from Top to Bottom\n      case Direction.S:\n        endI = startI + len - 1;\n        for (let i = startI; i <= endI; i++) {\n          res.push(fn(i, startJ, counter++));\n        }\n        break;\n      // from Bottom to Top\n      case Direction.N:\n        endI = startI - len + 1;\n        for (let i = startI; i >= endI; i--) {\n          res.push(fn(i, startJ, counter++));\n        }\n        break;\n\n      // i is decreasing\n      // j is increasing\n      case Direction.NE:\n        endJ = startJ + len - 1;\n        diff = Math.abs(endJ - startJ);\n        for (let i = 0; i <= diff; i++) {\n          res.push(fn(startI - i, startJ + i, counter++));\n        }\n        break;\n      // i is increasing\n      // j is decreasing\n      case Direction.SW:\n        endJ = startJ - len + 1;\n        diff = Math.abs(endJ - startJ);\n        for (let i = 0; i <= diff; i++) {\n          res.push(fn(startI + i, startJ - i, counter++));\n        }\n        break;\n      // i is decreasing\n      // j is decreasing\n      case Direction.NW:\n        endJ = startJ - len + 1;\n        diff = Math.abs(endJ - startJ);\n        for (let i = 0; i <= diff; i++) {\n          res.push(fn(startI - i, startJ - i, counter++));\n        }\n        break;\n\n      // i is increasing\n      // j is increasing\n      case Direction.SE:\n        endJ = startJ + len - 1;\n        diff = Math.abs(endJ - startJ);\n        for (let i = 0; i <= diff; i++) {\n          res.push(fn(startI + i, startJ + i, counter++));\n        }\n        break;\n    }\n    return res;\n  }\n\n  get offsetX() {\n    return this._offsetX;\n  }\n\n  get offsetY() {\n    return this._offsetY;\n  }\n\n  get boxSize() {\n    return this._boxSize;\n  }\n\n  get rows() {\n    return this.letterVals.length;\n  }\n\n  get cols() {\n    return this.letterVals?.[0]?.length || 0;\n  }\n\n  get topLeftPoint() {\n    return Point.from(this.offsetX, this.offsetY);\n  }\n\n  get topRightPoint() {\n    return Point.from(this.offsetX + this.boxSize * this.cols, this.offsetY);\n  }\n\n  get bottomLeftPoint() {\n    return Point.from(this.offsetX, this.offsetY + this.boxSize * this.rows);\n  }\n\n  get bottomRightPoint() {\n    return Point.from(\n      this.offsetX + this.boxSize * this.cols,\n      this.offsetY + this.boxSize * this.rows\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}