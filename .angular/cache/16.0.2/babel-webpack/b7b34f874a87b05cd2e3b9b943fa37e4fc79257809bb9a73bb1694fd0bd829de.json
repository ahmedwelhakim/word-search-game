{"ast":null,"code":"import { BehaviorSubject, map } from 'rxjs';\nimport { Angle } from '../models/angle.model';\nimport { Direction } from '../models/directions.model';\nimport { Point } from '../models/point.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas.service\";\nimport * as i2 from \"./board.service\";\nclass InputHandlerService {\n  constructor(canvasService, boardService, rendererFactory, window) {\n    this.canvasService = canvasService;\n    this.boardService = boardService;\n    this.rendererFactory = rendererFactory;\n    this.window = window;\n    this._startPoint$ = new BehaviorSubject(Point.from(-1, -1));\n    this._endPoint$ = new BehaviorSubject(Point.from(-1, -1));\n    this._pressed$ = new BehaviorSubject(false);\n    this.unlisitners = [];\n    console.log(window);\n    this.renderer = this.rendererFactory.createRenderer(null, null);\n    this.canvas = this.canvasService.canvas;\n    this.unlisitners = this.moveWhilePressDown(event => {\n      let endPoint = this.getPointFromEvent(event);\n      endPoint = this.getSnappedPoint(endPoint);\n      endPoint = this.getQuantizedPoint(endPoint);\n      if (endPoint.x !== this._endPoint$.value.x || endPoint.y !== this._endPoint$.value.y) {\n        this._endPoint$.next(endPoint);\n      }\n    });\n  }\n  ngOnDestroy() {\n    this.unlistenTo(...this.unlisitners);\n    console.log('Input Handler Service Destroyed');\n  }\n  get startEndPoints$() {\n    return this._endPoint$.asObservable().pipe(map(point => [this._startPoint$.value, point]));\n  }\n  get direction$() {\n    return this.startEndPoints$.pipe(map(([startPoint, endPoint]) => Direction.getDirection(startPoint, endPoint)));\n  }\n  get pressed$() {\n    return this._pressed$.asObservable();\n  }\n  getSnappedPoint(endPoint) {\n    let newX = endPoint.x;\n    let newY = endPoint.y;\n    let angle = Angle.angle(this._startPoint$.value, endPoint);\n    const snappedAngle = Direction.calcSnappedAngle(angle);\n    // Horizontal Line\n    if (snappedAngle === Direction.E || snappedAngle === Direction.W) {\n      newY = this._startPoint$.value.y;\n    }\n    // Vertical Line\n    else if (snappedAngle == Direction.N || snappedAngle == Direction.S) {\n      newX = this._startPoint$.value.x;\n    }\n    // 45 degree line\n    else {\n      const distance = Point.distance(this._startPoint$.value, endPoint);\n      const dx = endPoint.x - this._startPoint$.value.x;\n      const dy = endPoint.y - this._startPoint$.value.y;\n      const signX = dx > 0 ? 1 : -1;\n      const signY = dy > 0 ? 1 : -1;\n      newX = this._startPoint$.value.x + distance * Angle.cos(Angle.fromDeg(45)) * signX;\n      newY = this._startPoint$.value.y + distance * Angle.sin(Angle.fromDeg(45)) * signY;\n    }\n    return Point.from(newX, newY);\n  }\n  getQuantizedPoint(point) {\n    const boxSize = this.boardService.boxSize;\n    const halfBoxOffsetX = boxSize / 2;\n    const halfBoxOffsetY = boxSize / 2;\n    // *****************************************************************\n    // translate points to Board Table to top left\n    let x = point.x - this.boardService.offsetX;\n    let y = point.y - this.boardService.offsetY;\n    x = Math.floor(x / boxSize) * boxSize + halfBoxOffsetX;\n    y = Math.floor(y / boxSize) * boxSize + halfBoxOffsetY;\n    // ****************************************************************\n    // translate points back to their original\n    x += this.boardService.offsetX;\n    y += this.boardService.offsetY;\n    return Point.from(x, y);\n  }\n  moveWhilePressDown(whileMove) {\n    let unlistenMouseUpFn;\n    let unlistenMouseMoveFn;\n    let unlistenTouchMoveFn;\n    let unlistenTouchUpFn;\n    const endMove = () => {\n      this._pressed$.next(false);\n      this.unlistenTo(unlistenMouseMoveFn, unlistenTouchMoveFn, unlistenMouseUpFn, unlistenTouchUpFn);\n    };\n    const unlistenMouseDownFn = this.renderer.listen(this.canvas, 'mousedown', event => {\n      event.stopPropagation();\n      event.preventDefault();\n      // First click is handled here\n      let point = this.getPointFromEvent(event);\n      point = this.getQuantizedPoint(point);\n      this._startPoint$.next(point);\n      this._pressed$.next(true);\n      unlistenMouseMoveFn = this.renderer.listen(this.canvas, 'mousemove', whileMove);\n      unlistenMouseUpFn = this.renderer.listen(window, 'mouseup', endMove);\n    });\n    const unlistenTouchDownFn = this.renderer.listen(this.canvas, 'touchstart', event => {\n      event.stopPropagation();\n      event.preventDefault();\n      // First click is handled here\n      let point = this.getPointFromEvent(event);\n      point = this.getQuantizedPoint(point);\n      this._startPoint$.next(point);\n      this._pressed$.next(true);\n      unlistenTouchMoveFn = this.renderer.listen(this.canvas, 'touchmove', whileMove);\n      unlistenTouchUpFn = this.renderer.listen(window, 'touchend', endMove);\n    });\n    return [unlistenMouseDownFn, unlistenTouchDownFn];\n  }\n  getPointFromEvent(event) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (event instanceof MouseEvent) {\n      offsetX = event.offsetX;\n      offsetY = event.offsetY;\n    }\n    if (event instanceof TouchEvent) {\n      const boundRect = this.canvas.getBoundingClientRect();\n      offsetX = event.touches[0].clientX - boundRect.left;\n      offsetY = event.touches[0].clientY - boundRect.top;\n    }\n    return Point.from(offsetX, offsetY);\n  }\n  unlistenTo(...unlistenFns) {\n    for (let unlistener of unlistenFns) {\n      if (unlistener) {\n        unlistener();\n      }\n    }\n  }\n}\nInputHandlerService.ɵfac = function InputHandlerService_Factory(t) {\n  return new (t || InputHandlerService)(i0.ɵɵinject(i1.CanvasService), i0.ɵɵinject(i2.BoardService), i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject('Window'));\n};\nInputHandlerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InputHandlerService,\n  factory: InputHandlerService.ɵfac\n});\nexport { InputHandlerService };","map":{"version":3,"names":["BehaviorSubject","map","Angle","Direction","Point","InputHandlerService","constructor","canvasService","boardService","rendererFactory","window","_startPoint$","from","_endPoint$","_pressed$","unlisitners","console","log","renderer","createRenderer","canvas","moveWhilePressDown","event","endPoint","getPointFromEvent","getSnappedPoint","getQuantizedPoint","x","value","y","next","ngOnDestroy","unlistenTo","startEndPoints$","asObservable","pipe","point","direction$","startPoint","getDirection","pressed$","newX","newY","angle","snappedAngle","calcSnappedAngle","E","W","N","S","distance","dx","dy","signX","signY","cos","fromDeg","sin","boxSize","halfBoxOffsetX","halfBoxOffsetY","offsetX","offsetY","Math","floor","whileMove","unlistenMouseUpFn","unlistenMouseMoveFn","unlistenTouchMoveFn","unlistenTouchUpFn","endMove","unlistenMouseDownFn","listen","stopPropagation","preventDefault","unlistenTouchDownFn","MouseEvent","TouchEvent","boundRect","getBoundingClientRect","touches","clientX","left","clientY","top","unlistenFns","unlistener","i0","ɵɵinject","i1","CanvasService","i2","BoardService","RendererFactory2","factory","ɵfac"],"sources":["/home/ahmed/Documents/projects/word-matcher/src/app/game/services/input-handler.service.ts"],"sourcesContent":["import {\n  Inject,\n  Injectable,\n  OnDestroy,\n  Renderer2,\n  RendererFactory2,\n} from '@angular/core';\nimport { BehaviorSubject, map } from 'rxjs';\nimport { Angle } from '../models/angle.model';\nimport { Direction } from '../models/directions.model';\nimport { Point } from '../models/point.model';\nimport { BoardService } from './board.service';\nimport { CanvasService } from './canvas.service';\n\n@Injectable()\nexport class InputHandlerService implements OnDestroy {\n  private readonly canvas: HTMLCanvasElement;\n  private _startPoint$ = new BehaviorSubject<Point>(Point.from(-1, -1));\n  private _endPoint$ = new BehaviorSubject<Point>(Point.from(-1, -1));\n  private _pressed$ = new BehaviorSubject<boolean>(false);\n  private readonly unlisitners: (() => void)[] = [];\n  private renderer: Renderer2;\n\n  constructor(\n    private canvasService: CanvasService,\n    private boardService: BoardService,\n    private rendererFactory: RendererFactory2,\n    @Inject('Window') private window: Window\n  ) {\n    console.log(window)\n    this.renderer = this.rendererFactory.createRenderer(null, null);\n    this.canvas = this.canvasService.canvas;\n    this.unlisitners = this.moveWhilePressDown((event) => {\n      let endPoint = this.getPointFromEvent(event);\n      endPoint = this.getSnappedPoint(endPoint);\n      endPoint = this.getQuantizedPoint(endPoint);\n      if (\n        endPoint.x !== this._endPoint$.value.x ||\n        endPoint.y !== this._endPoint$.value.y\n      ) {\n        this._endPoint$.next(endPoint);\n      }\n    });\n  }\n  ngOnDestroy(): void {\n    this.unlistenTo(...this.unlisitners);\n    console.log('Input Handler Service Destroyed');\n  }\n\n  get startEndPoints$() {\n    return this._endPoint$\n      .asObservable()\n      .pipe(map((point): [Point, Point] => [this._startPoint$.value, point]));\n  }\n\n  get direction$() {\n    return this.startEndPoints$.pipe(\n      map(([startPoint, endPoint]) =>\n        Direction.getDirection(startPoint, endPoint)\n      )\n    );\n  }\n  get pressed$() {\n    return this._pressed$.asObservable();\n  }\n  private getSnappedPoint(endPoint: Point): Point {\n    let newX = endPoint.x;\n    let newY = endPoint.y;\n    let angle = Angle.angle(this._startPoint$.value, endPoint);\n    const snappedAngle = Direction.calcSnappedAngle(angle);\n\n    // Horizontal Line\n    if (snappedAngle === Direction.E || snappedAngle === Direction.W) {\n      newY = this._startPoint$.value.y ;\n    }\n\n    // Vertical Line\n    else if (snappedAngle == Direction.N || snappedAngle == Direction.S) {\n      newX = this._startPoint$.value.x ;\n    }\n    // 45 degree line\n    else {\n      const distance = Point.distance(this._startPoint$.value, endPoint);\n      const dx = endPoint.x - this._startPoint$.value.x;\n      const dy = endPoint.y - this._startPoint$.value.y;\n      const signX = dx > 0 ? 1 : -1;\n      const signY = dy > 0 ? 1 : -1;\n      newX =\n        this._startPoint$.value.x +\n        distance * Angle.cos(Angle.fromDeg(45)) * signX;\n      newY =\n        this._startPoint$.value.y +\n        distance * Angle.sin(Angle.fromDeg(45)) * signY;\n    }\n\n    return Point.from(newX, newY);\n  }\n  private getQuantizedPoint(point: Point): Point {\n    const boxSize = this.boardService.boxSize;\n    const halfBoxOffsetX = boxSize / 2;\n    const halfBoxOffsetY = boxSize / 2;\n\n    // *****************************************************************\n    // translate points to Board Table to top left\n    let x = point.x - this.boardService.offsetX;\n    let y = point.y - this.boardService.offsetY;\n\n    x = Math.floor(x / boxSize) * boxSize + halfBoxOffsetX;\n    y = Math.floor(y / boxSize) * boxSize + halfBoxOffsetY;\n\n    // ****************************************************************\n    // translate points back to their original\n    x += this.boardService.offsetX;\n    y += this.boardService.offsetY;\n\n    return Point.from(x, y);\n  }\n  private moveWhilePressDown(\n    whileMove: (event: MouseEvent | TouchEvent) => void\n  ) {\n    let unlistenMouseUpFn: () => void;\n    let unlistenMouseMoveFn: () => void;\n    let unlistenTouchMoveFn: () => void;\n    let unlistenTouchUpFn: () => void;\n\n    const endMove = () => {\n      this._pressed$.next(false);\n      this.unlistenTo(\n        unlistenMouseMoveFn,\n        unlistenTouchMoveFn,\n        unlistenMouseUpFn,\n        unlistenTouchUpFn\n      );\n    };\n\n    const unlistenMouseDownFn = this.renderer.listen(\n      this.canvas,\n      'mousedown',\n      (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        // First click is handled here\n        let point = this.getPointFromEvent(event);\n        point = this.getQuantizedPoint(point);\n        this._startPoint$.next(point);\n        this._pressed$.next(true);\n\n        unlistenMouseMoveFn = this.renderer.listen(\n          this.canvas,\n          'mousemove',\n          whileMove\n        );\n        unlistenMouseUpFn = this.renderer.listen(window, 'mouseup', endMove);\n      }\n    );\n\n    const unlistenTouchDownFn = this.renderer.listen(\n      this.canvas,\n      'touchstart',\n      (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        // First click is handled here\n        let point = this.getPointFromEvent(event);\n        point = this.getQuantizedPoint(point);\n        this._startPoint$.next(point);\n        this._pressed$.next(true);\n\n        unlistenTouchMoveFn = this.renderer.listen(\n          this.canvas,\n          'touchmove',\n          whileMove\n        );\n        unlistenTouchUpFn = this.renderer.listen(window, 'touchend', endMove);\n      }\n    );\n    return [unlistenMouseDownFn, unlistenTouchDownFn];\n  }\n\n  private getPointFromEvent(event: MouseEvent | TouchEvent) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (event instanceof MouseEvent) {\n      offsetX = event.offsetX;\n      offsetY = event.offsetY;\n    }\n    if (event instanceof TouchEvent) {\n      const boundRect = this.canvas.getBoundingClientRect();\n      offsetX = event.touches[0].clientX - boundRect.left;\n      offsetY = event.touches[0].clientY - boundRect.top;\n    }\n    return Point.from(offsetX, offsetY);\n  }\n  private unlistenTo(...unlistenFns: ((() => void) | undefined)[]) {\n    for (let unlistener of unlistenFns) {\n      if (unlistener) {\n        unlistener();\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}