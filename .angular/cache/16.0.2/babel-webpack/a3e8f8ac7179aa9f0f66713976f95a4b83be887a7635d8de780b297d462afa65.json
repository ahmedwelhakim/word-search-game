{"ast":null,"code":"import { BehaviorSubject, map } from 'rxjs';\nimport { Angle } from '../models/angle.model';\nimport { Direction } from '../models/directions.model';\nimport { Point } from '../models/point.model';\nimport { DOCUMENT } from \"@angular/common\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas.service\";\nimport * as i2 from \"./board.service\";\nclass InputHandlerService {\n  constructor(canvasService, boardService, rendererFactory, document) {\n    this.canvasService = canvasService;\n    this.boardService = boardService;\n    this.rendererFactory = rendererFactory;\n    this.document = document;\n    this._startPoint$ = new BehaviorSubject(Point.from(-1, -1));\n    this._endPoint$ = new BehaviorSubject(Point.from(-1, -1));\n    this._pressed$ = new BehaviorSubject(false);\n    this.unlisitners = [];\n    this.renderer = this.rendererFactory.createRenderer(null, null);\n    this.canvas = this.canvasService.canvas;\n    this.unlisitners = this.moveWhilePressDown(event => {\n      let endPoint = this.getPointFromEvent(event);\n      endPoint = this.getSnappedPoint(endPoint);\n      endPoint = this.getQuantizedPoint(endPoint);\n      this.window = this.document.defaultView;\n      if (endPoint.x !== this._endPoint$.value.x || endPoint.y !== this._endPoint$.value.y) {\n        this._endPoint$.next(endPoint);\n      }\n    });\n  }\n  ngOnDestroy() {\n    this.unlistenTo(...this.unlisitners);\n    console.log('Input Handler Service Destroyed');\n  }\n  get startEndPoints$() {\n    return this._endPoint$.asObservable().pipe(map(point => [this._startPoint$.value, point]));\n  }\n  get direction$() {\n    return this.startEndPoints$.pipe(map(([startPoint, endPoint]) => Direction.getDirection(startPoint, endPoint)));\n  }\n  get pressed$() {\n    return this._pressed$.asObservable();\n  }\n  getSnappedPoint(endPoint) {\n    let newX = endPoint.x;\n    let newY = endPoint.y;\n    let angle = Angle.angle(this._startPoint$.value, endPoint);\n    const snappedAngle = Direction.calcSnappedAngle(angle);\n    // Horizontal Line\n    if (snappedAngle === Direction.E || snappedAngle === Direction.W) {\n      newY = this._startPoint$.value.y;\n    }\n    // Vertical Line\n    else if (snappedAngle == Direction.N || snappedAngle == Direction.S) {\n      newX = this._startPoint$.value.x;\n    }\n    // 45 degree line\n    else {\n      const distance = Point.distance(this._startPoint$.value, endPoint);\n      const dx = endPoint.x - this._startPoint$.value.x;\n      const dy = endPoint.y - this._startPoint$.value.y;\n      const signX = dx > 0 ? 1 : -1;\n      const signY = dy > 0 ? 1 : -1;\n      newX = this._startPoint$.value.x + distance * Angle.cos(Angle.fromDeg(45)) * signX;\n      newY = this._startPoint$.value.y + distance * Angle.sin(Angle.fromDeg(45)) * signY;\n    }\n    return Point.from(newX, newY);\n  }\n  getQuantizedPoint(point) {\n    const boxSize = this.boardService.boxSize;\n    const halfBoxOffsetX = boxSize / 2;\n    const halfBoxOffsetY = boxSize / 2;\n    // *****************************************************************\n    // translate points to Board Table to top left\n    let x = point.x - this.boardService.offsetX;\n    let y = point.y - this.boardService.offsetY;\n    x = Math.floor(x / boxSize) * boxSize + halfBoxOffsetX;\n    y = Math.floor(y / boxSize) * boxSize + halfBoxOffsetY;\n    // ****************************************************************\n    // translate points back to their original\n    x += this.boardService.offsetX;\n    y += this.boardService.offsetY;\n    return Point.from(x, y);\n  }\n  moveWhilePressDown(whileMove) {\n    let unlistenMouseUpFn;\n    let unlistenMouseMoveFn;\n    let unlistenTouchMoveFn;\n    let unlistenTouchUpFn;\n    const endMove = () => {\n      this._pressed$.next(false);\n      this.unlistenTo(unlistenMouseMoveFn, unlistenTouchMoveFn, unlistenMouseUpFn, unlistenTouchUpFn);\n    };\n    const unlistenMouseDownFn = this.renderer.listen(this.canvas, 'mousedown', event => {\n      event.stopPropagation();\n      event.preventDefault();\n      // First click is handled here\n      let point = this.getPointFromEvent(event);\n      point = this.getQuantizedPoint(point);\n      this._startPoint$.next(point);\n      this._pressed$.next(true);\n      unlistenMouseMoveFn = this.renderer.listen(this.canvas, 'mousemove', whileMove);\n      unlistenMouseUpFn = this.renderer.listen(window, 'mouseup', endMove);\n    });\n    const unlistenTouchDownFn = this.renderer.listen(this.canvas, 'touchstart', event => {\n      event.stopPropagation();\n      event.preventDefault();\n      // First click is handled here\n      let point = this.getPointFromEvent(event);\n      point = this.getQuantizedPoint(point);\n      this._startPoint$.next(point);\n      this._pressed$.next(true);\n      unlistenTouchMoveFn = this.renderer.listen(this.canvas, 'touchmove', whileMove);\n      unlistenTouchUpFn = this.renderer.listen(window, 'touchend', endMove);\n    });\n    return [unlistenMouseDownFn, unlistenTouchDownFn];\n  }\n  getPointFromEvent(event) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (event instanceof MouseEvent) {\n      offsetX = event.offsetX;\n      offsetY = event.offsetY;\n    }\n    if (event instanceof TouchEvent) {\n      const boundRect = this.canvas.getBoundingClientRect();\n      offsetX = event.touches[0].clientX - boundRect.left;\n      offsetY = event.touches[0].clientY - boundRect.top;\n    }\n    return Point.from(offsetX, offsetY);\n  }\n  unlistenTo(...unlistenFns) {\n    for (let unlistener of unlistenFns) {\n      if (unlistener) {\n        unlistener();\n      }\n    }\n  }\n}\nInputHandlerService.ɵfac = function InputHandlerService_Factory(t) {\n  return new (t || InputHandlerService)(i0.ɵɵinject(i1.CanvasService), i0.ɵɵinject(i2.BoardService), i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(DOCUMENT));\n};\nInputHandlerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InputHandlerService,\n  factory: InputHandlerService.ɵfac\n});\nexport { InputHandlerService };","map":{"version":3,"names":["BehaviorSubject","map","Angle","Direction","Point","DOCUMENT","InputHandlerService","constructor","canvasService","boardService","rendererFactory","document","_startPoint$","from","_endPoint$","_pressed$","unlisitners","renderer","createRenderer","canvas","moveWhilePressDown","event","endPoint","getPointFromEvent","getSnappedPoint","getQuantizedPoint","window","defaultView","x","value","y","next","ngOnDestroy","unlistenTo","console","log","startEndPoints$","asObservable","pipe","point","direction$","startPoint","getDirection","pressed$","newX","newY","angle","snappedAngle","calcSnappedAngle","E","W","N","S","distance","dx","dy","signX","signY","cos","fromDeg","sin","boxSize","halfBoxOffsetX","halfBoxOffsetY","offsetX","offsetY","Math","floor","whileMove","unlistenMouseUpFn","unlistenMouseMoveFn","unlistenTouchMoveFn","unlistenTouchUpFn","endMove","unlistenMouseDownFn","listen","stopPropagation","preventDefault","unlistenTouchDownFn","MouseEvent","TouchEvent","boundRect","getBoundingClientRect","touches","clientX","left","clientY","top","unlistenFns","unlistener","i0","ɵɵinject","i1","CanvasService","i2","BoardService","RendererFactory2","factory","ɵfac"],"sources":["/home/ahmed/Documents/projects/word-matcher/src/app/game/services/input-handler.service.ts"],"sourcesContent":["import {\n  Inject,\n  Injectable,\n  OnDestroy,\n  Renderer2,\n  RendererFactory2,\n} from '@angular/core';\nimport { BehaviorSubject, map } from 'rxjs';\nimport { Angle } from '../models/angle.model';\nimport { Direction } from '../models/directions.model';\nimport { Point } from '../models/point.model';\nimport { BoardService } from './board.service';\nimport { CanvasService } from './canvas.service';\nimport {DOCUMENT} from \"@angular/common\";\n\n@Injectable()\nexport class InputHandlerService implements OnDestroy {\n  private readonly canvas: HTMLCanvasElement;\n  private _startPoint$ = new BehaviorSubject<Point>(Point.from(-1, -1));\n  private _endPoint$ = new BehaviorSubject<Point>(Point.from(-1, -1));\n  private _pressed$ = new BehaviorSubject<boolean>(false);\n  private readonly unlisitners: (() => void)[] = [];\n  private renderer: Renderer2;\n  private window: Window;\n  constructor(\n    private canvasService: CanvasService,\n    private boardService: BoardService,\n    private rendererFactory: RendererFactory2,\n    @Inject(DOCUMENT) private document: Document\n  ) {\n    this.renderer = this.rendererFactory.createRenderer(null, null);\n    this.canvas = this.canvasService.canvas;\n    this.unlisitners = this.moveWhilePressDown((event) => {\n      let endPoint = this.getPointFromEvent(event);\n      endPoint = this.getSnappedPoint(endPoint);\n      endPoint = this.getQuantizedPoint(endPoint);\n      this.window = this.document.defaultView\n      if (\n        endPoint.x !== this._endPoint$.value.x ||\n        endPoint.y !== this._endPoint$.value.y\n      ) {\n        this._endPoint$.next(endPoint);\n      }\n    });\n  }\n  ngOnDestroy(): void {\n    this.unlistenTo(...this.unlisitners);\n    console.log('Input Handler Service Destroyed');\n  }\n\n  get startEndPoints$() {\n    return this._endPoint$\n      .asObservable()\n      .pipe(map((point): [Point, Point] => [this._startPoint$.value, point]));\n  }\n\n  get direction$() {\n    return this.startEndPoints$.pipe(\n      map(([startPoint, endPoint]) =>\n        Direction.getDirection(startPoint, endPoint)\n      )\n    );\n  }\n  get pressed$() {\n    return this._pressed$.asObservable();\n  }\n  private getSnappedPoint(endPoint: Point): Point {\n    let newX = endPoint.x;\n    let newY = endPoint.y;\n    let angle = Angle.angle(this._startPoint$.value, endPoint);\n    const snappedAngle = Direction.calcSnappedAngle(angle);\n\n    // Horizontal Line\n    if (snappedAngle === Direction.E || snappedAngle === Direction.W) {\n      newY = this._startPoint$.value.y ;\n    }\n\n    // Vertical Line\n    else if (snappedAngle == Direction.N || snappedAngle == Direction.S) {\n      newX = this._startPoint$.value.x ;\n    }\n    // 45 degree line\n    else {\n      const distance = Point.distance(this._startPoint$.value, endPoint);\n      const dx = endPoint.x - this._startPoint$.value.x;\n      const dy = endPoint.y - this._startPoint$.value.y;\n      const signX = dx > 0 ? 1 : -1;\n      const signY = dy > 0 ? 1 : -1;\n      newX =\n        this._startPoint$.value.x +\n        distance * Angle.cos(Angle.fromDeg(45)) * signX;\n      newY =\n        this._startPoint$.value.y +\n        distance * Angle.sin(Angle.fromDeg(45)) * signY;\n    }\n\n    return Point.from(newX, newY);\n  }\n  private getQuantizedPoint(point: Point): Point {\n    const boxSize = this.boardService.boxSize;\n    const halfBoxOffsetX = boxSize / 2;\n    const halfBoxOffsetY = boxSize / 2;\n\n    // *****************************************************************\n    // translate points to Board Table to top left\n    let x = point.x - this.boardService.offsetX;\n    let y = point.y - this.boardService.offsetY;\n\n    x = Math.floor(x / boxSize) * boxSize + halfBoxOffsetX;\n    y = Math.floor(y / boxSize) * boxSize + halfBoxOffsetY;\n\n    // ****************************************************************\n    // translate points back to their original\n    x += this.boardService.offsetX;\n    y += this.boardService.offsetY;\n\n    return Point.from(x, y);\n  }\n  private moveWhilePressDown(\n    whileMove: (event: MouseEvent | TouchEvent) => void\n  ) {\n    let unlistenMouseUpFn: () => void;\n    let unlistenMouseMoveFn: () => void;\n    let unlistenTouchMoveFn: () => void;\n    let unlistenTouchUpFn: () => void;\n\n    const endMove = () => {\n      this._pressed$.next(false);\n      this.unlistenTo(\n        unlistenMouseMoveFn,\n        unlistenTouchMoveFn,\n        unlistenMouseUpFn,\n        unlistenTouchUpFn\n      );\n    };\n\n    const unlistenMouseDownFn = this.renderer.listen(\n      this.canvas,\n      'mousedown',\n      (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        // First click is handled here\n        let point = this.getPointFromEvent(event);\n        point = this.getQuantizedPoint(point);\n        this._startPoint$.next(point);\n        this._pressed$.next(true);\n\n        unlistenMouseMoveFn = this.renderer.listen(\n          this.canvas,\n          'mousemove',\n          whileMove\n        );\n        unlistenMouseUpFn = this.renderer.listen(window, 'mouseup', endMove);\n      }\n    );\n\n    const unlistenTouchDownFn = this.renderer.listen(\n      this.canvas,\n      'touchstart',\n      (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        // First click is handled here\n        let point = this.getPointFromEvent(event);\n        point = this.getQuantizedPoint(point);\n        this._startPoint$.next(point);\n        this._pressed$.next(true);\n\n        unlistenTouchMoveFn = this.renderer.listen(\n          this.canvas,\n          'touchmove',\n          whileMove\n        );\n        unlistenTouchUpFn = this.renderer.listen(window, 'touchend', endMove);\n      }\n    );\n    return [unlistenMouseDownFn, unlistenTouchDownFn];\n  }\n\n  private getPointFromEvent(event: MouseEvent | TouchEvent) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (event instanceof MouseEvent) {\n      offsetX = event.offsetX;\n      offsetY = event.offsetY;\n    }\n    if (event instanceof TouchEvent) {\n      const boundRect = this.canvas.getBoundingClientRect();\n      offsetX = event.touches[0].clientX - boundRect.left;\n      offsetY = event.touches[0].clientY - boundRect.top;\n    }\n    return Point.from(offsetX, offsetY);\n  }\n  private unlistenTo(...unlistenFns: ((() => void) | undefined)[]) {\n    for (let unlistener of unlistenFns) {\n      if (unlistener) {\n        unlistener();\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}