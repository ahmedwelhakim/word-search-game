{"ast":null,"code":"import { BehaviorSubject, map } from 'rxjs';\nimport { Angle } from '../models/angle.model';\nimport { Direction } from '../models/directions.model';\nimport { Point } from '../models/point.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas.service\";\nimport * as i2 from \"./board.service\";\nlet InputHandlerService = /*#__PURE__*/(() => {\n  class InputHandlerService {\n    constructor(canvasService, boardService, rendererFactory) {\n      this.canvasService = canvasService;\n      this.boardService = boardService;\n      this.rendererFactory = rendererFactory;\n      this._startPoint$ = new BehaviorSubject(Point.from(-1, -1));\n      this._endPoint$ = new BehaviorSubject(Point.from(-1, -1));\n      this._pressed$ = new BehaviorSubject(false);\n      this.unlisitners = [];\n      this.renderer = this.rendererFactory.createRenderer(null, null);\n      this.canvas = this.canvasService.canvas;\n      this.unlisitners = this.moveWhilePressDown(event => {\n        let endPoint = this.getPointFromEvent(event);\n        endPoint = this.getSnappedPoint(endPoint);\n        endPoint = this.getQuantizedPoint(endPoint);\n        if (endPoint.x !== this._endPoint$.value.x || endPoint.y !== this._endPoint$.value.y) {\n          this._endPoint$.next(endPoint);\n        }\n      });\n    }\n    ngOnDestroy() {\n      this.unlistenTo(...this.unlisitners);\n      console.log('Input Handler Service Destroyed');\n    }\n    get startEndPoints$() {\n      return this._endPoint$.asObservable().pipe(map(point => [this._startPoint$.value, point]));\n    }\n    get direction$() {\n      return this.startEndPoints$.pipe(map(([startPoint, endPoint]) => Direction.getDirection(startPoint, endPoint)));\n    }\n    get pressed$() {\n      return this._pressed$.asObservable();\n    }\n    getSnappedPoint(endPoint) {\n      let newX = endPoint.x;\n      let newY = endPoint.y;\n      let angle = Angle.angle(this._startPoint$.value, endPoint);\n      const snappedAngle = Direction.calcSnappedAngle(angle);\n      // Horizontal Line\n      if (snappedAngle === Direction.E || snappedAngle === Direction.W) {\n        newY = this._startPoint$.value.y;\n      }\n      // Vertical Line\n      else if (snappedAngle == Direction.N || snappedAngle == Direction.S) {\n        newX = this._startPoint$.value.x;\n      }\n      // 45 degree line\n      else {\n        const distance = Point.distance(this._startPoint$.value, endPoint);\n        const dx = endPoint.x - this._startPoint$.value.x;\n        const dy = endPoint.y - this._startPoint$.value.y;\n        const signX = dx > 0 ? 1 : -1;\n        const signY = dy > 0 ? 1 : -1;\n        newX = this._startPoint$.value.x + distance * Angle.cos(Angle.fromDeg(45)) * signX;\n        newY = this._startPoint$.value.y + distance * Angle.sin(Angle.fromDeg(45)) * signY;\n      }\n      return Point.from(newX, newY);\n    }\n    getQuantizedPoint(point) {\n      const boxSize = this.boardService.boxSize;\n      const halfBoxOffsetX = boxSize / 2;\n      const halfBoxOffsetY = boxSize / 2;\n      // *****************************************************************\n      // translate points to Board Table to top left\n      let x = point.x - this.boardService.offsetX;\n      let y = point.y - this.boardService.offsetY;\n      x = Math.floor(x / boxSize) * boxSize + halfBoxOffsetX;\n      y = Math.floor(y / boxSize) * boxSize + halfBoxOffsetY;\n      // ****************************************************************\n      // translate points back to their original\n      x += this.boardService.offsetX;\n      y += this.boardService.offsetY;\n      return Point.from(x, y);\n    }\n    moveWhilePressDown(whileMove) {\n      let unlistenMouseUpFn;\n      let unlistenMouseMoveFn;\n      let unlistenTouchMoveFn;\n      let unlistenTouchUpFn;\n      const endMove = () => {\n        this._pressed$.next(false);\n        this.unlistenTo(unlistenMouseMoveFn, unlistenTouchMoveFn, unlistenMouseUpFn, unlistenTouchUpFn);\n      };\n      const unlistenMouseDownFn = this.renderer.listen(this.canvas, 'mousedown', event => {\n        event.stopPropagation();\n        event.preventDefault();\n        // First click is handled here\n        let point = this.getPointFromEvent(event);\n        point = this.getQuantizedPoint(point);\n        this._startPoint$.next(point);\n        this._pressed$.next(true);\n        unlistenMouseMoveFn = this.renderer.listen(this.canvas, 'mousemove', whileMove);\n        unlistenMouseUpFn = this.renderer.listen(window, 'mouseup', endMove);\n      });\n      const unlistenTouchDownFn = this.renderer.listen(this.canvas, 'touchstart', event => {\n        event.stopPropagation();\n        event.preventDefault();\n        // First click is handled here\n        let point = this.getPointFromEvent(event);\n        point = this.getQuantizedPoint(point);\n        this._startPoint$.next(point);\n        this._pressed$.next(true);\n        unlistenTouchMoveFn = this.renderer.listen(this.canvas, 'touchmove', whileMove);\n        unlistenTouchUpFn = this.renderer.listen(window, 'touchend', endMove);\n      });\n      return [unlistenMouseDownFn, unlistenTouchDownFn];\n    }\n    getPointFromEvent(event) {\n      let offsetX = 0;\n      let offsetY = 0;\n      if ('MouseEvent' in window && event instanceof MouseEvent) {\n        offsetX = event.offsetX;\n        offsetY = event.offsetY;\n      }\n      if ('TouchEvent' in window && event instanceof TouchEvent) {\n        const boundRect = this.canvas.getBoundingClientRect();\n        offsetX = event.touches[0].clientX - boundRect.left;\n        offsetY = event.touches[0].clientY - boundRect.top;\n      }\n      return Point.from(offsetX, offsetY);\n    }\n    unlistenTo(...unlistenFns) {\n      for (let unlistener of unlistenFns) {\n        if (unlistener) {\n          unlistener();\n        }\n      }\n    }\n  }\n  InputHandlerService.ɵfac = function InputHandlerService_Factory(t) {\n    return new (t || InputHandlerService)(i0.ɵɵinject(i1.CanvasService), i0.ɵɵinject(i2.BoardService), i0.ɵɵinject(i0.RendererFactory2));\n  };\n  InputHandlerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: InputHandlerService,\n    factory: InputHandlerService.ɵfac\n  });\n  return InputHandlerService;\n})();\nexport { InputHandlerService };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}