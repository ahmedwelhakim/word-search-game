{"ast":null,"code":"import { BehaviorSubject, map } from 'rxjs';\nimport { Angle } from '../models/angle.model';\nimport { Direction } from '../models/directions.model';\nimport { Point } from '../models/point.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas.service\";\nimport * as i2 from \"./board.service\";\nclass InputHandlerService {\n  constructor(canvasService, boardService, rendererFactory) {\n    this.canvasService = canvasService;\n    this.boardService = boardService;\n    this.rendererFactory = rendererFactory;\n    this._startPoint$ = new BehaviorSubject(Point.from(-1, -1));\n    this._endPoint$ = new BehaviorSubject(Point.from(-1, -1));\n    this._pressed$ = new BehaviorSubject(false);\n    this.unlisitners = [];\n    this.renderer = this.rendererFactory.createRenderer(null, null);\n    this.canvas = this.canvasService.canvas;\n    this.unlisitners = this.moveWhilePressDown(event => {\n      let endPoint = this.getPointFromEvent(event);\n      endPoint = this.getSnappedPoint(endPoint);\n      endPoint = this.getQuantizedPoint(endPoint);\n      if (endPoint.x !== this._endPoint$.value.x || endPoint.y !== this._endPoint$.value.y) {\n        this._endPoint$.next(endPoint);\n      }\n    });\n  }\n  ngOnDestroy() {\n    this.unlistenTo(...this.unlisitners);\n    console.log('Input Handler Service Destroyed');\n  }\n  get startEndPoints$() {\n    return this._endPoint$.asObservable().pipe(map(point => [this._startPoint$.value, point]));\n  }\n  get direction$() {\n    return this.startEndPoints$.pipe(map(([startPoint, endPoint]) => Direction.getDirection(startPoint, endPoint)));\n  }\n  get pressed$() {\n    return this._pressed$.asObservable();\n  }\n  getSnappedPoint(endPoint) {\n    let newX = endPoint.x;\n    let newY = endPoint.y;\n    let angle = Angle.angle(this._startPoint$.value, endPoint);\n    const snappedAngle = Direction.calcSnappedAngle(angle);\n    // Horizontal Line\n    if (snappedAngle === Direction.E || snappedAngle === Direction.W) {\n      newY = this._startPoint$.value.y;\n    }\n    // Vertical Line\n    else if (snappedAngle == Direction.N || snappedAngle == Direction.S) {\n      newX = this._startPoint$.value.x;\n    }\n    // 45 degree line\n    else {\n      const distance = Point.distance(this._startPoint$.value, endPoint);\n      const dx = endPoint.x - this._startPoint$.value.x;\n      const dy = endPoint.y - this._startPoint$.value.y;\n      const signX = dx > 0 ? 1 : -1;\n      const signY = dy > 0 ? 1 : -1;\n      newX = this._startPoint$.value.x + distance * Angle.cos(Angle.fromDeg(45)) * signX;\n      newY = this._startPoint$.value.y + distance * Angle.sin(Angle.fromDeg(45)) * signY;\n    }\n    return Point.from(newX, newY);\n  }\n  getQuantizedPoint(point) {\n    const boxSize = this.boardService.boxSize;\n    const halfBoxOffsetX = boxSize / 2;\n    const halfBoxOffsetY = boxSize / 2;\n    // *****************************************************************\n    // translate points to Board Table to top left\n    let x = point.x - this.boardService.offsetX;\n    let y = point.y - this.boardService.offsetY;\n    x = Math.floor(x / boxSize) * boxSize + halfBoxOffsetX;\n    y = Math.floor(y / boxSize) * boxSize + halfBoxOffsetY;\n    // ****************************************************************\n    // translate points back to their original\n    x += this.boardService.offsetX;\n    y += this.boardService.offsetY;\n    return Point.from(x, y);\n  }\n  moveWhilePressDown(whileMove) {\n    let unlistenMouseUpFn;\n    let unlistenMouseMoveFn;\n    let unlistenTouchMoveFn;\n    let unlistenTouchUpFn;\n    const endMove = () => {\n      this._pressed$.next(false);\n      this.unlistenTo(unlistenMouseMoveFn, unlistenTouchMoveFn, unlistenMouseUpFn, unlistenTouchUpFn);\n    };\n    const unlistenMouseDownFn = this.renderer.listen(this.canvas, 'mousedown', event => {\n      event.stopPropagation();\n      event.preventDefault();\n      // First click is handled here\n      let point = this.getPointFromEvent(event);\n      point = this.getQuantizedPoint(point);\n      this._startPoint$.next(point);\n      this._pressed$.next(true);\n      unlistenMouseMoveFn = this.renderer.listen(this.canvas, 'mousemove', whileMove);\n      unlistenMouseUpFn = this.renderer.listen(window, 'mouseup', endMove);\n    });\n    const unlistenTouchDownFn = this.renderer.listen(this.canvas, 'touchstart', event => {\n      event.stopPropagation();\n      event.preventDefault();\n      // First click is handled here\n      let point = this.getPointFromEvent(event);\n      point = this.getQuantizedPoint(point);\n      this._startPoint$.next(point);\n      this._pressed$.next(true);\n      unlistenTouchMoveFn = this.renderer.listen(this.canvas, 'touchmove', whileMove);\n      unlistenTouchUpFn = this.renderer.listen(window, 'touchend', endMove);\n    });\n    return [unlistenMouseDownFn, unlistenTouchDownFn];\n  }\n  getPointFromEvent(event) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (event instanceof MouseEvent) {\n      offsetX = event.offsetX;\n      offsetY = event.offsetY;\n    }\n    if (event instanceof window.TouchEvent) {\n      const boundRect = this.canvas.getBoundingClientRect();\n      offsetX = event.touches[0].clientX - boundRect.left;\n      offsetY = event.touches[0].clientY - boundRect.top;\n    }\n    return Point.from(offsetX, offsetY);\n  }\n  unlistenTo(...unlistenFns) {\n    for (let unlistener of unlistenFns) {\n      if (unlistener) {\n        unlistener();\n      }\n    }\n  }\n}\nInputHandlerService.ɵfac = function InputHandlerService_Factory(t) {\n  return new (t || InputHandlerService)(i0.ɵɵinject(i1.CanvasService), i0.ɵɵinject(i2.BoardService), i0.ɵɵinject(i0.RendererFactory2));\n};\nInputHandlerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InputHandlerService,\n  factory: InputHandlerService.ɵfac\n});\nexport { InputHandlerService };","map":{"version":3,"names":["BehaviorSubject","map","Angle","Direction","Point","InputHandlerService","constructor","canvasService","boardService","rendererFactory","_startPoint$","from","_endPoint$","_pressed$","unlisitners","renderer","createRenderer","canvas","moveWhilePressDown","event","endPoint","getPointFromEvent","getSnappedPoint","getQuantizedPoint","x","value","y","next","ngOnDestroy","unlistenTo","console","log","startEndPoints$","asObservable","pipe","point","direction$","startPoint","getDirection","pressed$","newX","newY","angle","snappedAngle","calcSnappedAngle","E","W","N","S","distance","dx","dy","signX","signY","cos","fromDeg","sin","boxSize","halfBoxOffsetX","halfBoxOffsetY","offsetX","offsetY","Math","floor","whileMove","unlistenMouseUpFn","unlistenMouseMoveFn","unlistenTouchMoveFn","unlistenTouchUpFn","endMove","unlistenMouseDownFn","listen","stopPropagation","preventDefault","window","unlistenTouchDownFn","MouseEvent","TouchEvent","boundRect","getBoundingClientRect","touches","clientX","left","clientY","top","unlistenFns","unlistener","i0","ɵɵinject","i1","CanvasService","i2","BoardService","RendererFactory2","factory","ɵfac"],"sources":["/home/ahmed/Documents/projects/word-matcher/src/app/game/services/input-handler.service.ts"],"sourcesContent":["import {\n  Injectable,\n  OnDestroy,\n  Renderer2,\n  RendererFactory2,\n} from '@angular/core';\nimport { BehaviorSubject, map } from 'rxjs';\nimport { Angle } from '../models/angle.model';\nimport { Direction } from '../models/directions.model';\nimport { Point } from '../models/point.model';\nimport { BoardService } from './board.service';\nimport { CanvasService } from './canvas.service';\n\n@Injectable()\nexport class InputHandlerService implements OnDestroy {\n  private readonly canvas: HTMLCanvasElement;\n  private _startPoint$ = new BehaviorSubject<Point>(Point.from(-1, -1));\n  private _endPoint$ = new BehaviorSubject<Point>(Point.from(-1, -1));\n  private _pressed$ = new BehaviorSubject<boolean>(false);\n  private readonly unlisitners: (() => void)[] = [];\n  private renderer: Renderer2;\n  constructor(\n    private canvasService: CanvasService,\n    private boardService: BoardService,\n    private rendererFactory: RendererFactory2\n  ) {\n    this.renderer = this.rendererFactory.createRenderer(null, null);\n    this.canvas = this.canvasService.canvas;\n    this.unlisitners = this.moveWhilePressDown((event) => {\n      let endPoint = this.getPointFromEvent(event);\n      endPoint = this.getSnappedPoint(endPoint);\n      endPoint = this.getQuantizedPoint(endPoint);\n      if (\n        endPoint.x !== this._endPoint$.value.x ||\n        endPoint.y !== this._endPoint$.value.y\n      ) {\n        this._endPoint$.next(endPoint);\n      }\n    });\n  }\n  ngOnDestroy(): void {\n    this.unlistenTo(...this.unlisitners);\n    console.log('Input Handler Service Destroyed');\n  }\n\n  get startEndPoints$() {\n    return this._endPoint$\n      .asObservable()\n      .pipe(map((point): [Point, Point] => [this._startPoint$.value, point]));\n  }\n\n  get direction$() {\n    return this.startEndPoints$.pipe(\n      map(([startPoint, endPoint]) =>\n        Direction.getDirection(startPoint, endPoint)\n      )\n    );\n  }\n  get pressed$() {\n    return this._pressed$.asObservable();\n  }\n  private getSnappedPoint(endPoint: Point): Point {\n    let newX = endPoint.x;\n    let newY = endPoint.y;\n    let angle = Angle.angle(this._startPoint$.value, endPoint);\n    const snappedAngle = Direction.calcSnappedAngle(angle);\n\n    // Horizontal Line\n    if (snappedAngle === Direction.E || snappedAngle === Direction.W) {\n      newY = this._startPoint$.value.y ;\n    }\n\n    // Vertical Line\n    else if (snappedAngle == Direction.N || snappedAngle == Direction.S) {\n      newX = this._startPoint$.value.x ;\n    }\n    // 45 degree line\n    else {\n      const distance = Point.distance(this._startPoint$.value, endPoint);\n      const dx = endPoint.x - this._startPoint$.value.x;\n      const dy = endPoint.y - this._startPoint$.value.y;\n      const signX = dx > 0 ? 1 : -1;\n      const signY = dy > 0 ? 1 : -1;\n      newX =\n        this._startPoint$.value.x +\n        distance * Angle.cos(Angle.fromDeg(45)) * signX;\n      newY =\n        this._startPoint$.value.y +\n        distance * Angle.sin(Angle.fromDeg(45)) * signY;\n    }\n\n    return Point.from(newX, newY);\n  }\n  private getQuantizedPoint(point: Point): Point {\n    const boxSize = this.boardService.boxSize;\n    const halfBoxOffsetX = boxSize / 2;\n    const halfBoxOffsetY = boxSize / 2;\n\n    // *****************************************************************\n    // translate points to Board Table to top left\n    let x = point.x - this.boardService.offsetX;\n    let y = point.y - this.boardService.offsetY;\n\n    x = Math.floor(x / boxSize) * boxSize + halfBoxOffsetX;\n    y = Math.floor(y / boxSize) * boxSize + halfBoxOffsetY;\n\n    // ****************************************************************\n    // translate points back to their original\n    x += this.boardService.offsetX;\n    y += this.boardService.offsetY;\n\n    return Point.from(x, y);\n  }\n  private moveWhilePressDown(\n    whileMove: (event: MouseEvent | window.TouchEvent) => void\n  ) {\n    let unlistenMouseUpFn: () => void;\n    let unlistenMouseMoveFn: () => void;\n    let unlistenTouchMoveFn: () => void;\n    let unlistenTouchUpFn: () => void;\n\n    const endMove = () => {\n      this._pressed$.next(false);\n      this.unlistenTo(\n        unlistenMouseMoveFn,\n        unlistenTouchMoveFn,\n        unlistenMouseUpFn,\n        unlistenTouchUpFn\n      );\n    };\n\n    const unlistenMouseDownFn = this.renderer.listen(\n      this.canvas,\n      'mousedown',\n      (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        // First click is handled here\n        let point = this.getPointFromEvent(event);\n        point = this.getQuantizedPoint(point);\n        this._startPoint$.next(point);\n        this._pressed$.next(true);\n\n        unlistenMouseMoveFn = this.renderer.listen(\n          this.canvas,\n          'mousemove',\n          whileMove\n        );\n        unlistenMouseUpFn = this.renderer.listen(window, 'mouseup', endMove);\n      }\n    );\n\n    const unlistenTouchDownFn = this.renderer.listen(\n      this.canvas,\n      'touchstart',\n      (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        // First click is handled here\n        let point = this.getPointFromEvent(event);\n        point = this.getQuantizedPoint(point);\n        this._startPoint$.next(point);\n        this._pressed$.next(true);\n\n        unlistenTouchMoveFn = this.renderer.listen(\n          this.canvas,\n          'touchmove',\n          whileMove\n        );\n        unlistenTouchUpFn = this.renderer.listen(window, 'touchend', endMove);\n      }\n    );\n    return [unlistenMouseDownFn, unlistenTouchDownFn];\n  }\n\n  private getPointFromEvent(event: MouseEvent | window.TouchEvent) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (event instanceof MouseEvent) {\n      offsetX = event.offsetX;\n      offsetY = event.offsetY;\n    }\n    if (event instanceof window.TouchEvent) {\n      const boundRect = this.canvas.getBoundingClientRect();\n      offsetX = event.touches[0].clientX - boundRect.left;\n      offsetY = event.touches[0].clientY - boundRect.top;\n    }\n    return Point.from(offsetX, offsetY);\n  }\n  private unlistenTo(...unlistenFns: ((() => void) | undefined)[]) {\n    for (let unlistener of unlistenFns) {\n      if (unlistener) {\n        unlistener();\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}