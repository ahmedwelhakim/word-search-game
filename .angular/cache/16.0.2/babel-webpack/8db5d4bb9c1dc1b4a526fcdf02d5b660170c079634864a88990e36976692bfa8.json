{"ast":null,"code":"import { Direction } from '../models/directions.model';\nimport { Letter } from '../models/letter.model';\nimport { Point } from '../models/point.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas.service\";\nlet BoardService = /*#__PURE__*/(() => {\n  class BoardService {\n    constructor(canvasService) {\n      this.canvasService = canvasService;\n      this.letterVals = [];\n      this.letters = [];\n      this.lang = 'ar';\n      this._offsetX = 0;\n      this._offsetY = 0;\n      this._boxSize = 0;\n      this.usedLetterIndexesMap = new Map();\n      this.ctx = this.canvasService.ctx;\n    }\n    initLetterVals(rows, cols) {\n      // Fill the board with random letters\n      this.letterVals = [];\n      for (let i = 0; i < rows; i++) {\n        this.letterVals.push([]);\n        for (let j = 0; j < cols; j++) {\n          this.letterVals[i].push(Letter.getRandomLetter(this.lang));\n        }\n      }\n    }\n    initLetter(rows, cols) {\n      this.letters = [];\n      for (let i = 0; i < rows; i++) {\n        this.letters.push([]);\n        for (let j = 0; j < cols; j++) {\n          this.letters[i].push(Letter.from(this.letterVals[i][j], Point.from(0, 0), 0));\n        }\n      }\n    }\n    fillBoard(rows, cols, words) {\n      this.initLetterVals(rows, cols);\n      this.initLetter(rows, cols);\n      for (let word of words) {\n        const randDir = Direction.randomDirection;\n        const [startI, startJ] = this.getValidRandomBeginningIndex(word, randDir);\n        this.fillWord(word, startI, startJ, randDir);\n      }\n      this.updateLettersAndSizes();\n    }\n    fillWord(word, i, j, dir) {\n      const len = word.length;\n      const wordLettersReversed = word.split('').reverse();\n      this.doInDirection(dir, i, j, len, (i, j) => {\n        const letter = wordLettersReversed.pop();\n        this.letterVals[i][j] = letter;\n        this.letters[i][j].updateColors('khaki');\n        this.usedLetterIndexesMap.set(`${i},${j}`, letter);\n      });\n    }\n    getValidRandomBeginningIndex(word, direction) {\n      let randI = Math.floor(Math.random() * this.rows);\n      let randJ = Math.floor(Math.random() * this.cols);\n      while (!this.isValidIndex(randI, randJ, word, direction)) {\n        randI = Math.floor(Math.random() * this.rows);\n        randJ = Math.floor(Math.random() * this.cols);\n      }\n      return [randI, randJ];\n    }\n    isValidIndex(i, j, word, direction) {\n      const len = word.length;\n      const max_cols = this.cols;\n      const max_rows = this.rows;\n      let result = false;\n      switch (direction) {\n        case Direction.N:\n          result = i >= len - 1;\n          break;\n        case Direction.S:\n          result = i <= max_rows - len;\n          break;\n        case Direction.E:\n          result = j <= max_cols - len;\n          break;\n        case Direction.W:\n          result = j >= len - 1;\n          break;\n        case Direction.NE:\n          result = i >= len - 1 && j <= max_cols - len;\n          break;\n        case Direction.SE:\n          result = i <= max_rows - len && j <= max_cols - len;\n          break;\n        case Direction.NW:\n          result = i >= len - 1 && j >= len - 1;\n          break;\n        case Direction.SW:\n          result = i <= max_rows - len && j >= len - 1;\n          break;\n      }\n      if (!result) return false;\n      // Handle the case if letter will override other valid word letter\n      this.doInDirection(direction, i, j, len, (i2, j2, counter) => {\n        if (this.usedLetterIndexesMap.has(`${i2},${j2}`) && this.usedLetterIndexesMap.get(`${i2},${j2}`) !== word[counter]) {\n          result = false;\n        }\n      });\n      return result;\n    }\n    draw() {\n      this.ctx.beginPath();\n      for (let row of this.letters) {\n        for (let letter of row) {\n          letter.draw(this.ctx);\n        }\n      }\n    }\n    updateLettersAndSizes() {\n      const width = this.canvasService.canvas.width / this.cols;\n      const height = this.canvasService.canvas.height / this.rows;\n      this._boxSize = Math.min(width, height);\n      this._offsetX = (width - this.boxSize) * this.cols / 2;\n      this._offsetY = (height - this.boxSize) * this.rows / 2;\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j < this.cols; j++) {\n          this.letters[i][j].update(this.letterVals[i][j], Point.from(j * this.boxSize + this.offsetX, i * this.boxSize + this.offsetY), this.boxSize);\n        }\n      }\n    }\n    translatePointToIndices(point) {\n      // Remove all offsets\n      let offsetX = -this.boxSize / 2;\n      offsetX -= this._offsetX;\n      let offsetY = -this.boxSize / 2;\n      offsetY -= this._offsetY;\n      const j = Math.round((point.x + offsetX) / this.boxSize);\n      const i = Math.round((point.y + offsetY) / this.boxSize);\n      return [i, j];\n    }\n    isInBoard(...points) {\n      for (let point of points) {\n        if (point.x < this.topLeftPoint.x || point.x > this.bottomRightPoint.x) return false;\n        if (point.y < this.topLeftPoint.y || point.y > this.bottomRightPoint.y) return false;\n      }\n      return true;\n    }\n    getWord(startPoint, endPoint) {\n      if (!this.isInBoard(startPoint) || !this.isInBoard(endPoint)) return '';\n      const [i1, j1] = this.translatePointToIndices(startPoint);\n      const [i2, j2] = this.translatePointToIndices(endPoint);\n      const direction = Direction.getDirection(startPoint, endPoint);\n      let res = [];\n      const distanceLength = Math.max(Math.abs(i2 - i1), Math.abs(j2 - j1)) + 1;\n      if (i1 === i2 && j1 === j2) return this.letterVals?.[i1]?.[j1] || '';\n      res = this.doInDirection(direction, i1, j1, distanceLength, (i, j) => {\n        return this.letterVals?.[i]?.[j] || '';\n      });\n      return res.join('');\n    }\n    doInDirection(direction, startI, startJ, len, fn) {\n      const res = [];\n      let endI;\n      let endJ;\n      let diff;\n      let counter = 0;\n      switch (direction) {\n        // from Left To Right\n        case Direction.E:\n          endJ = startJ + len - 1;\n          for (let j = startJ; j <= endJ; j++) {\n            res.push(fn(startI, j, counter++));\n          }\n          break;\n        // from Right To Left\n        case Direction.W:\n          endJ = startJ - len + 1;\n          for (let j = startJ; j >= endJ; j--) {\n            res.push(fn(startI, j, counter++));\n          }\n          break;\n        // from Top to Bottom\n        case Direction.S:\n          endI = startI + len - 1;\n          for (let i = startI; i <= endI; i++) {\n            res.push(fn(i, startJ, counter++));\n          }\n          break;\n        // from Bottom to Top\n        case Direction.N:\n          endI = startI - len + 1;\n          for (let i = startI; i >= endI; i--) {\n            res.push(fn(i, startJ, counter++));\n          }\n          break;\n        // i is decreasing\n        // j is increasing\n        case Direction.NE:\n          endJ = startJ + len - 1;\n          diff = Math.abs(endJ - startJ);\n          for (let i = 0; i <= diff; i++) {\n            res.push(fn(startI - i, startJ + i, counter++));\n          }\n          break;\n        // i is increasing\n        // j is decreasing\n        case Direction.SW:\n          endJ = startJ - len + 1;\n          diff = Math.abs(endJ - startJ);\n          for (let i = 0; i <= diff; i++) {\n            res.push(fn(startI + i, startJ - i, counter++));\n          }\n          break;\n        // i is decreasing\n        // j is decreasing\n        case Direction.NW:\n          endJ = startJ - len + 1;\n          diff = Math.abs(endJ - startJ);\n          for (let i = 0; i <= diff; i++) {\n            res.push(fn(startI - i, startJ - i, counter++));\n          }\n          break;\n        // i is increasing\n        // j is increasing\n        case Direction.SE:\n          endJ = startJ + len - 1;\n          diff = Math.abs(endJ - startJ);\n          for (let i = 0; i <= diff; i++) {\n            res.push(fn(startI + i, startJ + i, counter++));\n          }\n          break;\n      }\n      return res;\n    }\n    get offsetX() {\n      return this._offsetX;\n    }\n    get offsetY() {\n      return this._offsetY;\n    }\n    get boxSize() {\n      return this._boxSize;\n    }\n    get rows() {\n      return this.letterVals.length;\n    }\n    get cols() {\n      return this.letterVals?.[0]?.length || 0;\n    }\n    get topLeftPoint() {\n      return Point.from(this.offsetX, this.offsetY);\n    }\n    get topRightPoint() {\n      return Point.from(this.offsetX + this.boxSize * this.cols, this.offsetY);\n    }\n    get bottomLeftPoint() {\n      return Point.from(this.offsetX, this.offsetY + this.boxSize * this.rows);\n    }\n    get bottomRightPoint() {\n      return Point.from(this.offsetX + this.boxSize * this.cols, this.offsetY + this.boxSize * this.rows);\n    }\n  }\n  BoardService.ɵfac = function BoardService_Factory(t) {\n    return new (t || BoardService)(i0.ɵɵinject(i1.CanvasService));\n  };\n  BoardService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: BoardService,\n    factory: BoardService.ɵfac\n  });\n  return BoardService;\n})();\nexport { BoardService };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}